<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Unix2016 | Necisam's blog]]></title>
  <link href="https://king4sam.github.io/blog/categories/unix2016/atom.xml" rel="self"/>
  <link href="https://king4sam.github.io/"/>
  <updated>2017-04-28T00:08:36+08:00</updated>
  <id>https://king4sam.github.io/</id>
  <author>
    <name><![CDATA[Necisam]]></name>
    <email><![CDATA[king4sam990816@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unix2016 Assignment10 Note]]></title>
    <link href="https://king4sam.github.io/blog/2017/01/11/unix2016-assignment10-note/"/>
    <updated>2017-01-11T17:36:45+08:00</updated>
    <id>https://king4sam.github.io/blog/2017/01/11/unix2016-assignment10-note</id>
    <content type="html"><![CDATA[<h1 id="requirements">Requirements</h1>

<ol>
  <li>
    <p>Write a program to determine your system’s byte ordering. Explain how does it work and present your test results.</p>
  </li>
  <li>
    <p>Write a client program and a server program to continuously report the number of processes currently running on a specified host (UNIX) computer. Make sure your server supports multiple concurrent clients and handle socket-related exceptions.</p>
  </li>
</ol>

<!--more-->

<hr />

<h1 id="implements">Implements</h1>

<ol>
  <li>byte ordering
    <ul>
      <li>用casting，將int(32bit) cast 成 char(8bit)</li>
      <li>檢查char 是哪兩個byte，就能知道系統的byte ordering</li>
    </ul>
  </li>
  <li>socket
    <ul>
      <li>sysinfo contains procs,</li>
    </ul>
  </li>
</ol>

<p><code>c get current # process
struct sysinfo si;
sysinfo(&amp;si);
printf("num of process : %d", si.proc);
</code></p>

<ul>
  <li>server</li>
</ul>

<ol>
  <li>getaddrinfo(), traversal the result list to get a available socket</li>
  <li>socket() create a socket descriptor</li>
  <li>bind() bind portnumber with the socket descriptor</li>
  <li>listen() listen on the port</li>
  <li>accept() wait for a connection</li>
  <li>after accept a connection, create a new process to handle clients</li>
  <li>write sth to the socket descriptor</li>
</ol>

<ul>
  <li>client
    <ol>
      <li>getaddrinfo(), traversal the result list to get a available socket</li>
      <li>socket() create a socket descriptors</li>
      <li>connect() connect to remote host</li>
      <li>read() read from the socket descriptor</li>
    </ol>
  </li>
</ul>

<p><a href="https://github.com/king4sam/nthu-unix2016/tree/master/assignment10">links to assignment10</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix2016 Assignment7 Note]]></title>
    <link href="https://king4sam.github.io/blog/2016/12/22/unix2016-assignment7-note/"/>
    <updated>2016-12-22T10:49:25+08:00</updated>
    <id>https://king4sam.github.io/blog/2016/12/22/unix2016-assignment7-note</id>
    <content type="html"><![CDATA[<h1 id="requirements">Requirements</h1>

<p>To implement Terminal Control and Signal Handling to support Job Control.
<!--more--></p>

<ul>
  <li>Signal Handling: user can terminate the running process with Ctrl+C without quitting from your shell</li>
  <li>Background processes without resulting in zombies</li>
  <li>Foreground/Background Switching: Your shell is able to put the process to the background (“&amp;”) and bring background process back to the foreground by “fg” command</li>
  <li>Built-in functions: jobs, fg
    <ul>
      <li>“Jobs” allows users to view all the processes</li>
      <li>“fg” <shell_assigned_process_id>” (You will need to handle the id by yourself)</shell_assigned_process_id></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="implements">Implements</h1>

<ul>
  <li>set tsh controlling process as current foreground process</li>
</ul>

<p>The function tcgetpgrp() returns the process group ID of the foreground process group on the terminal associated to fd, which must be the controlling terminal of the calling process.</p>

<p><code>c SYNOPSIS https://linux.die.net/man/3/tcgetpgrp
int tcsetpgrp(int fd, pid_t pgrp);
</code></p>

<ul>
  <li>
    <p>signal hanlding</p>

    <p>Control process should ignore terminate signal(SIGINT…)</p>

    <p>Control process set child process as foreground to access STDIN, so that child process would receive the signal from STDIN.</p>

    <p>Control process need to set signal handler for child process, preventing children becoming a zombie process</p>

    <p>there some special func defined
  - SIG_DFL is defalt handler
  - SIG_IGN is to ignore the signal</p>
  </li>
</ul>

<p><code>c SYNOPSIS https://linux.die.net/man/3/signal
void (*signal(int sig, void (*func)(int)))(int);
</code></p>

<ul>
  <li>
    <p>job control</p>

    <p>implement a job queue to add/remove job while forking a new background process</p>
  </li>
  <li>
    <p>fg cmd</p>

    <p>control process set given jobid as foreground process and send SIGCONT to job to wake it</p>
  </li>
  <li>
    <p>extra note</p>

    <p>in SIGCHLD handler, use while to catch childe process’s return status.</p>
  </li>
</ul>

<p><a href="https://github.com/king4sam/nthu-unix2016/tree/master/assignment7">links to assignment7</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix2016 Assignment6 Note]]></title>
    <link href="https://king4sam.github.io/blog/2016/11/29/unix2016-assignment6-note/"/>
    <updated>2016-11-29T11:40:29+08:00</updated>
    <id>https://king4sam.github.io/blog/2016/11/29/unix2016-assignment6-note</id>
    <content type="html"><![CDATA[<h1 id="requirements">Requirements</h1>

<p>We will write a tiny shell (tsh) command processor like sh, bash, or csh for single line commands. Your shell’s main loop will display a prompt, read a line of input, and fork a child process to perform the indicated command.
<!--more-->
—</p>

<p>Required capabilities:</p>

<ol>
  <li>
    <p>Ordinary commands, consisting of an executable program name and an optional list of arguments, run in a separate process.</p>
  </li>
  <li>
    <p>Two built-in commands: cd and pwd</p>
  </li>
  <li>
    <p>Background processing, when the last token in the command line is “&amp;”.</p>
  </li>
</ol>

<h1 id="implementation">Implementation</h1>

<ol>
  <li>
    <p>get user input</p>
  </li>
  <li>
    <p>parse oneline cmd , create command argv &amp;</p>
  </li>
  <li>
    <p>if cmd is build-in cmd, call corresponding system call</p>
  </li>
  <li>
    <p>if not, create a child process, and execvp the cmd
<code>
The exec family of functions replaces the current process image with a new process image.
</code></p>
  </li>
  <li>
    <p>if it is not a background process, use waitpid for childprocess</p>
  </li>
</ol>

<p><a href="https://github.com/king4sam/nthu-unix2016/tree/master/assignment6">links to assignment6</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix2016 Assignment4 Note]]></title>
    <link href="https://king4sam.github.io/blog/2016/11/08/unix2016-assignment4-note/"/>
    <updated>2016-11-08T10:43:31+08:00</updated>
    <id>https://king4sam.github.io/blog/2016/11/08/unix2016-assignment4-note</id>
    <content type="html"><![CDATA[<h1 id="requirements">Requirements</h1>
<p>Your tool will load this dictionary into memory, and tries to concatenate three words into the plaintext password candidate. Use the crypt library to find the actually password of a person. The TA will time how fast your code can break the password. The top 10% of the student will receive 2 bonus points.</p>

<!--more-->
<hr />

<ol>
  <li>
    <p>Your tool, say decrypt, that reads the hashed password from a file, and output the decrypted password. (sample test case can be downloaded from the iLms)</p>
  </li>
  <li>
    <p>The password is composed of three random words from the given dictionary file.</p>
  </li>
  <li>
    <p>You will need to check how to get a hashed string as explained during the lecture.</p>
  </li>
</ol>

<h1 id="implementation">Implementation</h1>

<ul>
  <li>more detail on user password</li>
</ul>

<p><code>
$6$naIJPKfO$SMkeSkFM36M6u3mZIyf2hAtt31WxuYtoTwLMjF9Fv49cprYPKtR1K88Ox5xvQdLdoBrAOmCnomRvaHc7VDiqQ0
</code>
<code>
$Algorithmid$Salt$Encryptedpassword
</code></p>

<ul>
  <li>algorithmid table</li>
</ul>

<table>
  <thead>
    <tr>
      <th>ID</th>
      <th>Method</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>MD5</td>
    </tr>
    <tr>
      <td>2a</td>
      <td>Blowfish (not in mainline glibc; added in some Linux distributions)</td>
    </tr>
    <tr>
      <td>5</td>
      <td>SHA-256 (since glibc 2.7)</td>
    </tr>
    <tr>
      <td>6</td>
      <td>SHA-512 (since glibc 2.7)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>dictionary attack</li>
</ul>

<p><a href="https://github.com/king4sam/nthu-unix2016/tree/master/assignment4">links to assignment4</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix2016 Assignment3 Note]]></title>
    <link href="https://king4sam.github.io/blog/2016/11/01/unix2016-assignment3-note/"/>
    <updated>2016-11-01T00:41:05+08:00</updated>
    <id>https://king4sam.github.io/blog/2016/11/01/unix2016-assignment3-note</id>
    <content type="html"><![CDATA[<h1 id="requirements">Requirements</h1>
<!--more-->

<ol>
  <li>Write a utility like cp(1), say lcp, that copies a file containing holes, without copying the hole to the target file. Instead, your utility writes “\0” to fill those holes in the target file.
    <ul>
      <li>lcp only needs to support basic copy feature; copying a file to another file. (usage : lcp <source_file> <destination_file>)</destination_file></source_file></li>
      <li>Your output file should be identical to the original input file (size, content), but the block usage on the disk is different.</li>
      <li>You need to check how to create a file with holes as explained in Chapter 3.</li>
      <li>The test cases will be regular files, and you don’t have to handle any unusual exceptions.</li>
    </ul>
  </li>
  <li>In Section 4.22, our version of ftw, called ftw8.c, never changes its directory. Modify this routine so that each time it encounters a directory, it uses the chdir function to change to that directory, allowing it to use the filename and not the pathname for each call to lstat. When all the entries in a directory have been processed, execute chdir(“..”). Compare the time consumed by this version and the version in the text book.
    <ul>
      <li>Trace the ftw8 source code given by TA. (compile with “make ftw8”)</li>
      <li>Modify the code with chdir</li>
    </ul>
  </li>
</ol>

<hr />

<h1 id="implementation">Implementation</h1>

<ol>
  <li>
    <p>用read/write就符合需求了，唯一要注意的是lcp後的檔案權限也要跟原檔一樣</p>
  </li>
  <li>
    <p>chdir()，不過給絕對路徑跟相對路徑在檔案數多時還是有效能的差距</p>
  </li>
</ol>

<p><a href="https://github.com/king4sam/nthu-unix2016/tree/master/assignment3">link to assignment3</a></p>
]]></content>
  </entry>
  
</feed>
